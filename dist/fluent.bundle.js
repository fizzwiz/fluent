!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.fluent=e():t.fluent=e()}(self,()=>(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{AsyncEach:()=>i,Each:()=>a,Path:()=>n,Scope:()=>r,What:()=>o});class r{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return a.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return a.along(this,t=>t.parent)}}class n extends r{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new n).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new n(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new a;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class o{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),o.as((...r)=>a.equal(t,r)?e:void 0)}static as(t){if(t instanceof o)return t;if("function"!=typeof t){const e=t;t=t=>t===e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,o.prototype),e.what=t,e}static#t(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t){return o.#t(o.if(this,t),this)}static if(t,e=t=>void 0!==t){return o.as((...r)=>o.what(e,...r)?o.what(t,...r):void 0)}sthen(t){return o.#t(o.sthen(this,t),this)}static sthen(...t){return o.as(e=>{let r=e;for(let e of t){if(void 0===r)break;r=o.what(e,r)}return r})}else(t,e=void 0){const r="string"==typeof e?e:void 0,n=e instanceof RegExp?e:void 0;return o.#t((...e)=>{let o;try{o=this(...e)}catch(t){const e=t.message??JSON.stringify(t);if(!(r&&r===e||n&&n.test(e)))throw t;o=void 0}return void 0===o&&(o=t(...e)),o},this)}static else(...t){return o.as(e=>{let r;for(let n of t){try{r=o.what(n,e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=t=>void 0!==t){return o.#t(o.which(this,t),this)}static which(t,e=t=>void 0!==t){return o.as(r=>a.as(o.what(t,r)).which((t,n)=>e(t,n,r)))}when(t,e=!0,r=e){return o.#t(o.when(this,t,e,r),this)}static when(t,e,r=!0,n=r){const i="number"==typeof e;return o.as((...s)=>{const c=i?e:(t,r)=>o.what(e,t,r,...s);return a.as(o.what(t,...s)).when(c,r,n)})}match(...t){return o.#t(o.match(this,...t),this)}static match(...t){const e=t.length<2?e=>{const r=o.what(t[0],e);return r[Symbol.iterator]?a.as(r).sthen(t=>[e,t]):[e,r]}:e=>t.map(t=>o.what(t,e));return o.as(e)}each(t){return o.#t((...e)=>a.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return o.as(e=>{const r=e instanceof n?e:n.of(e);return r.length>t.length?a.of():r.across(a.as(o.what(t[r.length-1],r.last)).which()).which()})}self(t=void 0,e=void 0){return o.#t(o.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?e=>e.across(a.as(o.what(t,e.last)).which()):(...e)=>{const n=o.what(t,...e);if(void 0===n)return;const i={};return i[r]=n,i}:"number"==typeof e?(...n)=>{const i=n.splice(e,0,r);return o.what(t,...i)}:n=>{const i=a.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t),s=o.what("string"==typeof t?n[t]:t,...i);if(void 0!==s)return void 0!==r?(n[r]=s,n):s},o.as(n)}static what(t,...e){return t instanceof o?t.what(...e):"function"==typeof t?t(...e):t}}class i{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new i;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){if(t instanceof i)return t;if(null!=t&&"function"==typeof t[Symbol.asyncIterator]){const e=new i;return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},e}if(null!=t&&"function"==typeof t[Symbol.iterator]){const e=new i;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e},e}return i.of(t)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return i.equal(this,t)}static along(t,e){const r=new i;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await o.what(e,r)},r}static async equal(t,e){const r=i.as(t)[Symbol.asyncIterator](),n=i.as(e)[Symbol.asyncIterator]();for(;;){const[t,e]=await Promise.all([r.next(),n.next()]);if(t.done||e.done)return t.done===e.done;if(t.value instanceof i||e.value instanceof i){if(!await i.equal(t.value,e.value))return!1}else if(t.value!==e.value)return!1}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new i;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new i;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?i.else(this):i.else([this,i.as(t)])}static else(t){const e=new i;return e[Symbol.asyncIterator]=async function*(){for await(const e of i.as(t)){const t=i.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return i.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},i.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const a=new i;return a[Symbol.asyncIterator]=r?async function*(){let r=0,i=!1;for await(const a of t)i?yield a:await o.what(e,a,r)&&(i=!0,n&&(yield a)),r++}:async function*(){let r=0,i=!1;for await(const a of t){if(i)break;await o.what(e,a,r)?(i=!0,n&&(yield a)):yield a,r++}},a}match(t=void 0){return void 0===t?i.match(this):i.match(this,i.as(t))}static match(...t){const e=new i,r=t.map(t=>i.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return i.each(...this);const e=this,r=new i;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of i.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>i.as(t));return o.as(t=>{if(t.length>=e.length)return i.of();const r=e[t.length],n=new i;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return i.self(this)}static self(t){const e=i.as(t),r=new i;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return i.what(this,t,e)}static async what(t,e,r){const n=i.as(t);if(e){let t=void 0!==r;for await(const i of n)t?r=await o.what(e,r,i):(r=i,t=!0);return r}for await(const t of n)return t}}class a{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return a.of();if(t instanceof a)return t;if(t[Symbol.iterator]){const e=new a;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new a;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new a;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new a;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=o.what(e,r)},r}toArray(){return Array.from(this)}equals(t){return a.equal(this,t)}static equal(t,e){if("string"==typeof t||!a.isIterable(t)||"string"==typeof e||!a.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!a.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return a.if(this,t)}static if(t,e=t=>void 0!==t){return a.which(t,e)}sthen(t){return a.sthen(this,t)}static sthen(t,e){const r=new a;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield o.what(e,n,r++)},r}else(t=void 0){return void 0===t?a.else(this):a.else(a.of(this,a.as(t)))}static else(t){const e=new a;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return a.which(this,t)}static which(t,e=t=>void 0!==t){const r=new a;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)o.what(e,n,r++)&&(yield n)},r}when(t,e=!0,r=e){return a.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},i.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new a;return s[Symbol.iterator]=r?function*(){let r=0,i=!1;for(let a of t)i?yield a:o.what(e,a,r)&&(i=!0,n&&(yield a)),r++}:function*(){let r=0,i=!1;for(let a of t){if(i)break;o.what(e,a,r)?(i=!0,n&&(yield a)):yield a,r++}},s}match(t=void 0){return void 0===t?a.match(...this):a.match(this,a.as(t))}static match(...t){const e=new a;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return a.each(...this);const e=this,r=new a;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of a.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),o.as(e=>e.length<t.length?e.across(t[e.length]):a.of())}self(){return a.self(this)}static self(t){const e=new a;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return a.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=a.what(t),t=a.when(t,1));for(let n of t)r=o.what(e,r,n);return r}for(let e of t)return e}}return a.NATURAL=new a,a.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++},e})());
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.fluent=e():t.fluent=e()}(self,(()=>(()=>{"use strict";var t={d:(e,r)=>{for(var o in r)t.o(r,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:r[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Each:()=>h,Path:()=>s,Scope:()=>n,What:()=>a,core:()=>r,util:()=>o});var r={};t.r(r),t.d(r,{Each:()=>h,What:()=>a});var o={};t.r(o),t.d(o,{Path:()=>s,Scope:()=>n});class n{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which((e=>t.every((t=>void 0!==e[t])))).then((e=>e[t[0]])).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return h.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return h.along(this,(t=>t.parent))}}class s extends n{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new s).along(t)}static ofProperties(t,e,r=void 0){let o=new s,n=t;for(let t of e){if(void 0===n[t]&&r&&(n[t]=a.what(r,n,t)),void 0===n[t])break;o=o.add(n[t]),n=n[t]}return o}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new s(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new h;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let o=this;for(;0<t;)r[t-1]=e(o.last),o=o.prev,t--;return r}}class a{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw"abstract method!"}static as(t){if(t instanceof a)return t;if("function"==typeof t){const e=new a;return e.what=t,e}return a.as((e=>e===t))}toFunc(){return(...t)=>this.what(...t)}static of(t,e){Array.isArray(t)||(t=[t]);const r=new a;return r.what=(...r)=>h.equal(r,t)?e:void 0,r}if(t=t=>void 0!==t){return a.if(this,t)}which(t=t=>void 0!==t){return a.which(this,t)}when(t,e=!0,r=e){return a.when(this,t,e,r)}then(t){return a.then(this,t)}else(t){return a.else(this,t)}match(...t){return a.match(this,...t)}each(t){const e=new a;return e.what=(...e)=>{const r=new h,o=h.as(this.what(...e)).which().toArray();return r[Symbol.iterator]=function*(){for(let e of o)for(let r of h.as(a.what(t,e)).which())yield r},r},e}self(t=void 0,e=void 0){return a.self(this,t,e)}static if(t,e=t=>void 0!==t){return a.as((r=>a.what(e,r)?a.what(t,r):void 0))}static which(t,e=t=>void 0!==t){return a.as((r=>h.as(a.what(t,r)).which(((t,o)=>e(t,o,r)))))}static when(t,e,r=!0,o=r){const n="number"==typeof e;return a.as(((...i)=>{const s=n?e:(t,r)=>a.what(e,t,r,...i);return h.as(a.what(t,...i)).when(s,r,o)}))}static then(...t){return a.as((e=>{let r=e;for(let e of t){if(void 0===r)break;r=r instanceof Promise?r.then(e):a.what(e,r)}return r}))}static else(...t){return a.as((e=>{let r;for(let o of t){try{r=a.what(o,e)}catch(t){r=void 0}if(void 0!==r)break}return r}))}static what(t,...e){return t instanceof a?t.what(...e):"function"==typeof t?t(...e):t}static match(...t){const e=t.length<2?e=>{const r=a.what(t[0],e);return r[Symbol.iterator]?h.as(r).then((t=>[e,t])):[e,r]}:e=>t.map((t=>a.what(t,e)));return a.as(e)}static each(...t){return a.as((e=>{const r=e instanceof s?e:s.of(e);return r.length>t.length?h.of():r.across(h.as(a.what(t[r.length-1],r.last)).which()).which()}))}static self(t,e=void 0,r=void 0){let o;return o=void 0===e?void 0===r?e=>e.across(h.as(a.what(t,e.last)).which()):(...e)=>{const o=a.what(t,...e);if(void 0===o)return;const n={};return n[r]=o,n}:"number"==typeof e?(...e)=>{const o=e.splice(i,0,r);return a.what(t,...o)}:o=>{const n=h.as("string"==typeof e?[e]:e).then((t=>"string"==typeof t?o[t]:t)),i=a.what("string"==typeof t?o[t]:t,...n);return void 0===i?void 0:void 0!==r?(o[r]=i,o):i},a.as(o)}}class h{[Symbol.iterator](){throw"abstract method!"}toArray(){return Array.from(this)}equals(t){return h.equal(this,t)}if(t=t=>void 0!==t){return h.if(this,t)}which(t=t=>void 0!==t){return h.which(this,t)}then(t){return h.then(this,t)}else(t=void 0){return void 0===t?h.else(this):h.else(h.of(this,h.as(t)))}match(t=void 0){return void 0===t?h.match(...this):h.match(this,h.as(t))}each(t=void 0){if(void 0===t)return h.each(...this);const e=this,r=new h;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of h.as(t))yield[r,e]},r}when(t,e=!0,r=e){return h.when(this,t,e,r)}self(){return h.self(this)}what(t=void 0,e=void 0){return h.what(this,t,e)}static as(t){if(void 0===t)return h.of();if(t instanceof h)return t;if(t[Symbol.iterator]){const e=new h;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}return h.of(t)}static of(...t){return h.as(t)}static along(t,e){const r=new h;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=a.what(e,r)},r}static equal(t,e){if("string"==typeof t||!h.isIterable(t)||"string"==typeof e||!h.isIterable(e))return t===e;{const r=t[Symbol.iterator](),o=e[Symbol.iterator]();for(;;){const t=r.next(),e=o.next();if(t.done||e.done)return t.done===e.done;if(!h.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}static if(t,e=t=>void 0!==t){return h.which(t,e)}static which(t,e=t=>void 0!==t){const r=new h;return r[Symbol.iterator]=function*(){let r=0;for(let o of t)a.what(e,o,r++)&&(yield o)},r}static self(t){const e=new h;return e[Symbol.iterator]=function*(){for(;;)yield t},e}static then(t,e){const r=new h;return r[Symbol.iterator]=function*(){let r=0;for(let o of t)yield a.what(e,o,r++)},r}static else(t){const e=new h;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}static match(...t){const e=new h;return e[Symbol.iterator]=function*(){const e=t.map((t=>t[Symbol.iterator]()));for(;;){const t=e.map((t=>t.next()));if(t.some((t=>t.done)))break;yield t.map((t=>t.value))}},e}static each(...t){return t=t.map((t=>t[Symbol.iterator]?t:[t])),a.as((e=>e.length<t.length?e.across(t[e.length]):h.of()))}static when(t,e,r=!0,o=r){if("number"==typeof e){const t=e;e=(e,r)=>r===t}const n=new h;return n[Symbol.iterator]=r?function*(){let r=0,n=!1;for(let i of t)n?yield i:a.what(e,i,r)&&(n=!0,o&&(yield i)),r++}:function*(){let r=0,n=!1;for(let i of t){if(n)break;a.what(e,i,r)?(n=!0,o&&(yield i)):yield i,r++}},n}static what(t,e,r){if(e){void 0===r&&(r=h.what(t),t=h.when(t,1));for(let o of t)r=a.what(e,r,o);return r}for(let e of t)return e}}return h.NATURAL=new h,h.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++},e})()));